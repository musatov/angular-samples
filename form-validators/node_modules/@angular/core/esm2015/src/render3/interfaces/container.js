/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HOST, NEXT, PARENT, T_HOST } from './view';
/**
 * Special location which allows easy identification of type. If we have an array which was
 * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is
 * `LContainer`.
 * @type {?}
 */
export const TYPE = 1;
/**
 * Below are constants for LContainer indices to help us look up LContainer members
 * without having to remember the specific indices.
 * Uglify will inline these when minifying so there shouldn't be a cost.
 * @type {?}
 */
export const ACTIVE_INDEX = 2;
// PARENT and NEXT are indices 3 and 4
// As we already have these constants in LView, we don't need to re-create them.
/** @type {?} */
export const MOVED_VIEWS = 5;
// T_HOST is index 6
// We already have this constants in LView, we don't need to re-create it.
/** @type {?} */
export const NATIVE = 7;
/** @type {?} */
export const VIEW_REFS = 8;
/**
 * Size of LContainer's header. Represents the index after which all views in the
 * container will be inserted. We need to keep a record of current views so we know
 * which views are already in the DOM (and don't need to be re-added) and so we can
 * remove views from the DOM when they are no longer required.
 * @type {?}
 */
export const CONTAINER_HEADER_OFFSET = 9;
/** @enum {number} */
const ActiveIndexFlag = {
    /**
     * Flag which signifies that the `LContainer` does not have any inline embedded views.
     */
    DYNAMIC_EMBEDDED_VIEWS_ONLY: -1,
    /**
     * Flag to signify that this `LContainer` may have transplanted views which need to be change
     * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.
     *
     * This flag once set is never unset for the `LContainer`. This means that when unset we can skip
     * a lot of work in `refreshDynamicEmbeddedViews`. But when set we still need to verify
     * that the `MOVED_VIEWS` are transplanted and on-push.
     */
    HAS_TRANSPLANTED_VIEWS: 1,
    /**
     * Number of bits to shift inline embedded views counter to make space for other flags.
     */
    SHIFT: 1,
    /**
     * When incrementing the active index for inline embedded views, the amount to increment to leave
     * space for other flags.
     */
    INCREMENT: 2,
};
export { ActiveIndexFlag };
/**
 * The state associated with a container.
 *
 * This is an array so that its structure is closer to LView. This helps
 * when traversing the view tree (which is a mix of containers and component
 * views), so we can jump to viewOrContainer[NEXT] in the same way regardless
 * of type.
 * @record
 */
export function LContainer() { }
if (false) {
    /* Skipping unnamed member:
    readonly[HOST]: RElement|RComment|LView;*/
    /* Skipping unnamed member:
    [TYPE]: true;*/
    /* Skipping unnamed member:
    [ACTIVE_INDEX]: ActiveIndexFlag;*/
    /* Skipping unnamed member:
    [PARENT]: LView;*/
    /* Skipping unnamed member:
    [NEXT]: LView|LContainer|null;*/
    /* Skipping unnamed member:
    [MOVED_VIEWS]: LView[]|null;*/
    /* Skipping unnamed member:
    [T_HOST]: TNode;*/
    /* Skipping unnamed member:
    readonly[NATIVE]:
          RComment;*/
    /* Skipping unnamed member:
    [VIEW_REFS]: ViewRef[]|null;*/
}
// Note: This hack is necessary so we don't erroneously get a circular dependency
// failure based on types.
/** @type {?} */
export const unusedValueExportToPlacateAjd = 1;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnRlcmZhY2VzL2NvbnRhaW5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFBLE9BQU8sRUFBQyxJQUFJLEVBQVMsSUFBSSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUMsTUFBTSxRQUFRLENBQUM7Ozs7Ozs7QUFRekQsTUFBTSxPQUFPLElBQUksR0FBRyxDQUFDOzs7Ozs7O0FBTXJCLE1BQU0sT0FBTyxZQUFZLEdBQUcsQ0FBQzs7OztBQUs3QixNQUFNLE9BQU8sV0FBVyxHQUFHLENBQUM7Ozs7QUFLNUIsTUFBTSxPQUFPLE1BQU0sR0FBRyxDQUFDOztBQUN2QixNQUFNLE9BQU8sU0FBUyxHQUFHLENBQUM7Ozs7Ozs7O0FBUTFCLE1BQU0sT0FBTyx1QkFBdUIsR0FBRyxDQUFDOzs7SUFTdEM7O09BRUc7SUFDSCwrQkFBZ0M7SUFFaEM7Ozs7Ozs7T0FPRztJQUNILHlCQUEwQjtJQUUxQjs7T0FFRztJQUNILFFBQVM7SUFHVDs7O09BR0c7SUFDSCxZQUFzQjs7Ozs7Ozs7Ozs7O0FBV3hCLGdDQWlFQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlELE1BQU0sT0FBTyw2QkFBNkIsR0FBRyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1ZpZXdSZWZ9IGZyb20gJy4uLy4uL2xpbmtlci92aWV3X3JlZic7XG5cbmltcG9ydCB7VE5vZGV9IGZyb20gJy4vbm9kZSc7XG5pbXBvcnQge1JDb21tZW50LCBSRWxlbWVudH0gZnJvbSAnLi9yZW5kZXJlcic7XG5cbmltcG9ydCB7SE9TVCwgTFZpZXcsIE5FWFQsIFBBUkVOVCwgVF9IT1NUfSBmcm9tICcuL3ZpZXcnO1xuXG5cbi8qKlxuICogU3BlY2lhbCBsb2NhdGlvbiB3aGljaCBhbGxvd3MgZWFzeSBpZGVudGlmaWNhdGlvbiBvZiB0eXBlLiBJZiB3ZSBoYXZlIGFuIGFycmF5IHdoaWNoIHdhc1xuICogcmV0cmlldmVkIGZyb20gdGhlIGBMVmlld2AgYW5kIHRoYXQgYXJyYXkgaGFzIGB0cnVlYCBhdCBgVFlQRWAgbG9jYXRpb24sIHdlIGtub3cgaXQgaXNcbiAqIGBMQ29udGFpbmVyYC5cbiAqL1xuZXhwb3J0IGNvbnN0IFRZUEUgPSAxO1xuLyoqXG4gKiBCZWxvdyBhcmUgY29uc3RhbnRzIGZvciBMQ29udGFpbmVyIGluZGljZXMgdG8gaGVscCB1cyBsb29rIHVwIExDb250YWluZXIgbWVtYmVyc1xuICogd2l0aG91dCBoYXZpbmcgdG8gcmVtZW1iZXIgdGhlIHNwZWNpZmljIGluZGljZXMuXG4gKiBVZ2xpZnkgd2lsbCBpbmxpbmUgdGhlc2Ugd2hlbiBtaW5pZnlpbmcgc28gdGhlcmUgc2hvdWxkbid0IGJlIGEgY29zdC5cbiAqL1xuZXhwb3J0IGNvbnN0IEFDVElWRV9JTkRFWCA9IDI7XG5cbi8vIFBBUkVOVCBhbmQgTkVYVCBhcmUgaW5kaWNlcyAzIGFuZCA0XG4vLyBBcyB3ZSBhbHJlYWR5IGhhdmUgdGhlc2UgY29uc3RhbnRzIGluIExWaWV3LCB3ZSBkb24ndCBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVtLlxuXG5leHBvcnQgY29uc3QgTU9WRURfVklFV1MgPSA1O1xuXG4vLyBUX0hPU1QgaXMgaW5kZXggNlxuLy8gV2UgYWxyZWFkeSBoYXZlIHRoaXMgY29uc3RhbnRzIGluIExWaWV3LCB3ZSBkb24ndCBuZWVkIHRvIHJlLWNyZWF0ZSBpdC5cblxuZXhwb3J0IGNvbnN0IE5BVElWRSA9IDc7XG5leHBvcnQgY29uc3QgVklFV19SRUZTID0gODtcblxuLyoqXG4gKiBTaXplIG9mIExDb250YWluZXIncyBoZWFkZXIuIFJlcHJlc2VudHMgdGhlIGluZGV4IGFmdGVyIHdoaWNoIGFsbCB2aWV3cyBpbiB0aGVcbiAqIGNvbnRhaW5lciB3aWxsIGJlIGluc2VydGVkLiBXZSBuZWVkIHRvIGtlZXAgYSByZWNvcmQgb2YgY3VycmVudCB2aWV3cyBzbyB3ZSBrbm93XG4gKiB3aGljaCB2aWV3cyBhcmUgYWxyZWFkeSBpbiB0aGUgRE9NIChhbmQgZG9uJ3QgbmVlZCB0byBiZSByZS1hZGRlZCkgYW5kIHNvIHdlIGNhblxuICogcmVtb3ZlIHZpZXdzIGZyb20gdGhlIERPTSB3aGVuIHRoZXkgYXJlIG5vIGxvbmdlciByZXF1aXJlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IENPTlRBSU5FUl9IRUFERVJfT0ZGU0VUID0gOTtcblxuXG4vKipcbiAqIFVzZWQgdG8gdHJhY2s6XG4gKiAgLSBJbmxpbmUgZW1iZWRkZWQgdmlld3MgKHNlZTogYMm1ybVlbWJlZGRlZFZpZXdTdGFydGApXG4gKiAgLSBUcmFuc3BsYW50ZWQgYExWaWV3YHMgKHNlZTogYExWaWV3W0RFQ0xBUkFUSU9OX0NPTVBPTkVOVF9WSUVXXSlgXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEFjdGl2ZUluZGV4RmxhZyB7XG4gIC8qKlxuICAgKiBGbGFnIHdoaWNoIHNpZ25pZmllcyB0aGF0IHRoZSBgTENvbnRhaW5lcmAgZG9lcyBub3QgaGF2ZSBhbnkgaW5saW5lIGVtYmVkZGVkIHZpZXdzLlxuICAgKi9cbiAgRFlOQU1JQ19FTUJFRERFRF9WSUVXU19PTkxZID0gLTEsXG5cbiAgLyoqXG4gICAqIEZsYWcgdG8gc2lnbmlmeSB0aGF0IHRoaXMgYExDb250YWluZXJgIG1heSBoYXZlIHRyYW5zcGxhbnRlZCB2aWV3cyB3aGljaCBuZWVkIHRvIGJlIGNoYW5nZVxuICAgKiBkZXRlY3RlZC4gKHNlZTogYExWaWV3W0RFQ0xBUkFUSU9OX0NPTVBPTkVOVF9WSUVXXSlgLlxuICAgKlxuICAgKiBUaGlzIGZsYWcgb25jZSBzZXQgaXMgbmV2ZXIgdW5zZXQgZm9yIHRoZSBgTENvbnRhaW5lcmAuIFRoaXMgbWVhbnMgdGhhdCB3aGVuIHVuc2V0IHdlIGNhbiBza2lwXG4gICAqIGEgbG90IG9mIHdvcmsgaW4gYHJlZnJlc2hEeW5hbWljRW1iZWRkZWRWaWV3c2AuIEJ1dCB3aGVuIHNldCB3ZSBzdGlsbCBuZWVkIHRvIHZlcmlmeVxuICAgKiB0aGF0IHRoZSBgTU9WRURfVklFV1NgIGFyZSB0cmFuc3BsYW50ZWQgYW5kIG9uLXB1c2guXG4gICAqL1xuICBIQVNfVFJBTlNQTEFOVEVEX1ZJRVdTID0gMSxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQgaW5saW5lIGVtYmVkZGVkIHZpZXdzIGNvdW50ZXIgdG8gbWFrZSBzcGFjZSBmb3Igb3RoZXIgZmxhZ3MuXG4gICAqL1xuICBTSElGVCA9IDEsXG5cblxuICAvKipcbiAgICogV2hlbiBpbmNyZW1lbnRpbmcgdGhlIGFjdGl2ZSBpbmRleCBmb3IgaW5saW5lIGVtYmVkZGVkIHZpZXdzLCB0aGUgYW1vdW50IHRvIGluY3JlbWVudCB0byBsZWF2ZVxuICAgKiBzcGFjZSBmb3Igb3RoZXIgZmxhZ3MuXG4gICAqL1xuICBJTkNSRU1FTlQgPSAxIDw8IFNISUZULFxufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggYSBjb250YWluZXIuXG4gKlxuICogVGhpcyBpcyBhbiBhcnJheSBzbyB0aGF0IGl0cyBzdHJ1Y3R1cmUgaXMgY2xvc2VyIHRvIExWaWV3LiBUaGlzIGhlbHBzXG4gKiB3aGVuIHRyYXZlcnNpbmcgdGhlIHZpZXcgdHJlZSAod2hpY2ggaXMgYSBtaXggb2YgY29udGFpbmVycyBhbmQgY29tcG9uZW50XG4gKiB2aWV3cyksIHNvIHdlIGNhbiBqdW1wIHRvIHZpZXdPckNvbnRhaW5lcltORVhUXSBpbiB0aGUgc2FtZSB3YXkgcmVnYXJkbGVzc1xuICogb2YgdHlwZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMQ29udGFpbmVyIGV4dGVuZHMgQXJyYXk8YW55PiB7XG4gIC8qKlxuICAgKiBUaGUgaG9zdCBlbGVtZW50IG9mIHRoaXMgTENvbnRhaW5lci5cbiAgICpcbiAgICogVGhlIGhvc3QgY291bGQgYmUgYW4gTFZpZXcgaWYgdGhpcyBjb250YWluZXIgaXMgb24gYSBjb21wb25lbnQgbm9kZS5cbiAgICogSW4gdGhhdCBjYXNlLCB0aGUgY29tcG9uZW50IExWaWV3IGlzIGl0cyBIT1NULlxuICAgKi9cbiAgcmVhZG9ubHlbSE9TVF06IFJFbGVtZW50fFJDb21tZW50fExWaWV3O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgdHlwZSBmaWVsZCB3aGljaCBhbGxvd3MgdXMgdG8gZGlmZmVyZW50aWF0ZSBgTENvbnRhaW5lcmAgZnJvbSBgU3R5bGluZ0NvbnRleHRgIGluIGFuXG4gICAqIGVmZmljaWVudCB3YXkuIFRoZSB2YWx1ZSBpcyBhbHdheXMgc2V0IHRvIGB0cnVlYFxuICAgKi9cbiAgW1RZUEVdOiB0cnVlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmV4dCBhY3RpdmUgaW5kZXggaW4gdGhlIHZpZXdzIGFycmF5IHRvIHJlYWQgb3Igd3JpdGUgdG8uIFRoaXMgaGVscHMgdXNcbiAgICoga2VlcCB0cmFjayBvZiB3aGVyZSB3ZSBhcmUgaW4gdGhlIHZpZXdzIGFycmF5LlxuICAgKiBJbiB0aGUgY2FzZSB0aGUgTENvbnRhaW5lciBpcyBjcmVhdGVkIGZvciBhIFZpZXdDb250YWluZXJSZWYsXG4gICAqIGl0IGlzIHNldCB0byBudWxsIHRvIGlkZW50aWZ5IHRoaXMgc2NlbmFyaW8sIGFzIGluZGljZXMgYXJlIFwiYWJzb2x1dGVcIiBpbiB0aGF0IGNhc2UsXG4gICAqIGkuZS4gcHJvdmlkZWQgZGlyZWN0bHkgYnkgdGhlIHVzZXIgb2YgdGhlIFZpZXdDb250YWluZXJSZWYgQVBJLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgYnkgYMm1ybVlbWJlZGRlZFZpZXdTdGFydGAgdG8gdHJhY2sgd2hpY2ggYExWaWV3YCBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgKiBCZWNhdXNlIGDJtcm1ZW1iZWRkZWRWaWV3U3RhcnRgIGlzIG5vdCBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyIHRoaXMgZmVhdHVyZSBpcyBlc3NlbnRpYWxseVxuICAgKiB1bnVzZWQuXG4gICAqXG4gICAqIFRoZSBsb3dlc3QgYml0IHNpZ25hbHMgdGhhdCB0aGlzIGBMQ29udGFpbmVyYCBoYXMgdHJhbnNwbGFudGVkIHZpZXdzIHdoaWNoIG5lZWQgdG8gYmUgY2hhbmdlXG4gICAqIGRldGVjdGVkIGFzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9uIENELiAoU2VlIGBMVmlld1tERUNMQVJBVElPTl9DT01QT05FTlRfVklFV11gKVxuICAgKi9cbiAgW0FDVElWRV9JTkRFWF06IEFjdGl2ZUluZGV4RmxhZztcblxuICAvKipcbiAgICogQWNjZXNzIHRvIHRoZSBwYXJlbnQgdmlldyBpcyBuZWNlc3Nhcnkgc28gd2UgY2FuIHByb3BhZ2F0ZSBiYWNrXG4gICAqIHVwIGZyb20gaW5zaWRlIGEgY29udGFpbmVyIHRvIHBhcmVudFtORVhUXS5cbiAgICovXG4gIFtQQVJFTlRdOiBMVmlldztcblxuICAvKipcbiAgICogVGhpcyBhbGxvd3MgdXMgdG8ganVtcCBmcm9tIGEgY29udGFpbmVyIHRvIGEgc2libGluZyBjb250YWluZXIgb3IgY29tcG9uZW50XG4gICAqIHZpZXcgd2l0aCB0aGUgc2FtZSBwYXJlbnQsIHNvIHdlIGNhbiByZW1vdmUgbGlzdGVuZXJzIGVmZmljaWVudGx5LlxuICAgKi9cbiAgW05FWFRdOiBMVmlld3xMQ29udGFpbmVyfG51bGw7XG5cbiAgLyoqXG4gICAqIEEgY29sbGVjdGlvbiBvZiB2aWV3cyBjcmVhdGVkIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIGA8bmctdGVtcGxhdGU+YCBlbGVtZW50IGJ1dCBpbnNlcnRlZCBpbnRvXG4gICAqIGEgZGlmZmVyZW50IGBMQ29udGFpbmVyYC4gV2UgbmVlZCB0byB0cmFjayB2aWV3cyBjcmVhdGVkIGZyb20gYSBnaXZlbiBkZWNsYXJhdGlvbiBwb2ludCBzaW5jZVxuICAgKiBxdWVyaWVzIGNvbGxlY3QgbWF0Y2hlcyBmcm9tIHRoZSBlbWJlZGRlZCB2aWV3IGRlY2xhcmF0aW9uIHBvaW50IGFuZCBfbm90XyB0aGUgaW5zZXJ0aW9uIHBvaW50LlxuICAgKi9cbiAgW01PVkVEX1ZJRVdTXTogTFZpZXdbXXxudWxsO1xuXG4gIC8qKlxuICAgKiBQb2ludGVyIHRvIHRoZSBgVE5vZGVgIHdoaWNoIHJlcHJlc2VudHMgdGhlIGhvc3Qgb2YgdGhlIGNvbnRhaW5lci5cbiAgICovXG4gIFtUX0hPU1RdOiBUTm9kZTtcblxuICAvKiogVGhlIGNvbW1lbnQgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyBhbiBhbmNob3IgZm9yIHRoaXMgTENvbnRhaW5lci4gKi9cbiAgcmVhZG9ubHlbTkFUSVZFXTpcbiAgICAgIFJDb21tZW50OyAgLy8gVE9ETyhtaXNrbyk6IHJlbW92ZSBhcyB0aGlzIHZhbHVlIGNhbiBiZSBnb3R0ZW4gYnkgdW53cmFwcGluZyBgW0hPU1RdYFxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBgVmlld1JlZmBzIHVzZWQgYnkgYW55IGBWaWV3Q29udGFpbmVyUmVmYHMgdGhhdCBwb2ludCB0byB0aGlzIGNvbnRhaW5lci5cbiAgICpcbiAgICogVGhpcyBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYnkgYFZpZXdDb250YWluZXJSZWZgIHdoZW4gdGhlIGZpcnN0IHZpZXcgaXMgaW5zZXJ0ZWQuXG4gICAqL1xuICBbVklFV19SRUZTXTogVmlld1JlZltdfG51bGw7XG59XG5cbi8vIE5vdGU6IFRoaXMgaGFjayBpcyBuZWNlc3Nhcnkgc28gd2UgZG9uJ3QgZXJyb25lb3VzbHkgZ2V0IGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuLy8gZmFpbHVyZSBiYXNlZCBvbiB0eXBlcy5cbmV4cG9ydCBjb25zdCB1bnVzZWRWYWx1ZUV4cG9ydFRvUGxhY2F0ZUFqZCA9IDE7XG4iXX0=